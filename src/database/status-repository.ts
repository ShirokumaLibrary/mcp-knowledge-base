import { BaseRepository, Database } from './base.js';
import { Status } from '../types/domain-types.js';

/**
 * @ai-context Repository for workflow status management
 * @ai-pattern Simple CRUD repository for status definitions
 * @ai-critical Statuses are referenced by ID - deletion can break referential integrity
 * @ai-lifecycle Statuses created at DB init, custom ones added by users
 * @ai-assumption Default statuses (1-6) should not be deleted
 */
export class StatusRepository extends BaseRepository {
  constructor(db: Database) {
    super(db, 'StatusRepository');
  }

  /**
   * @ai-intent Retrieve all available workflow statuses
   * @ai-flow 1. Query all statuses -> 2. Map to typed objects -> 3. Return sorted by ID
   * @ai-performance Cached by UI layer - called frequently
   * @ai-return Always returns array, empty if table not initialized
   * @ai-why Ordered by ID to show default statuses first
   */
  async getAllStatuses(): Promise<Status[]> {
    const rows = await this.db.allAsync(
      'SELECT id, name, created_at FROM statuses ORDER BY id'
    );
    
    // @ai-logic: Type safety through explicit mapping
    return rows.map((row: any) => ({
      id: row.id,
      name: row.name,
      created_at: row.created_at
    }));
  }

  async getAllStatusesAsync(): Promise<Status[]> {
    return this.getAllStatuses();
  }

  async getStatus(id: number): Promise<Status | null> {
    const row = await this.db.getAsync(
      'SELECT id, name, created_at FROM statuses WHERE id = ?',
      [id]
    );
    
    if (!row) return null;
    return {
      id: row.id,
      name: row.name,
      created_at: row.created_at
    };
  }

  /**
   * @ai-intent Create custom workflow status
   * @ai-flow 1. Insert with auto-increment ID -> 2. Return complete object
   * @ai-side-effects Adds to statuses table, ID generated by AUTOINCREMENT
   * @ai-error-handling Throws on duplicate names (UNIQUE constraint)
   * @ai-critical IDs 7+ are custom statuses that need preservation during rebuilds
   */
  async createStatus(name: string): Promise<Status> {
    const result = await this.db.runAsync(
      'INSERT INTO statuses (name) VALUES (?)',
      [name]
    );
    
    return {
      id: (result as any).lastID!,  // @ai-assumption: SQLite always provides lastID
      name,
      created_at: new Date().toISOString()
    };
  }

  async updateStatus(id: number, name: string): Promise<boolean> {
    const result = await this.db.runAsync(
      'UPDATE statuses SET name = ? WHERE id = ?',
      [name, id]
    );
    
    return (result as any).changes! > 0;
  }

  /**
   * @ai-intent Remove status definition
   * @ai-flow 1. Execute DELETE -> 2. Check affected rows -> 3. Return success
   * @ai-critical Can break issues/plans using this status - no cascade delete
   * @ai-warning Should prevent deletion of default statuses (1-6) at app layer
   * @ai-return True if deleted, false if not found
   */
  async deleteStatus(id: number): Promise<boolean> {
    const result = await this.db.runAsync(
      'DELETE FROM statuses WHERE id = ?',
      [id]
    );
    
    // @ai-logic: changes > 0 means row was actually deleted
    return (result as any).changes! > 0;
  }
}