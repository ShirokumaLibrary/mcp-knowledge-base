---
allowed-tools: [Bash(git:*), Read, Grep]
description: Create conventional commits following project guidelines
classification: L1_UNIVERSAL
version: 1.0.0
---

## Language
Note: Language settings are configured in MCP steering documents

## CURRENT CONTEXT

GIT STATUS:
```
!git status --porcelain
```

RECENT CHANGES:
```
!git diff --stat HEAD~1
```

## OBJECTIVE

Create clean, atomic commits with conventional messages that accurately describe changes, maintain project history integrity, and follow established patterns without unnecessary automation signatures.

## Purpose
Create well-structured commits with conventional commit messages, maintaining project history and documentation standards. This command is universally applicable to any git repository.

## CRITICAL INSTRUCTIONS

1. **ATOMIC COMMITS**: Each commit must represent exactly one logical change
2. **NO AI SIGNATURES**: Never include "Generated by AI", "Co-authored-by: Claude", "ü§ñ", or any AI-related references in commit messages
3. **NO CLAUDE CODE SIGNATURES**: Do NOT add "Generated with Claude Code" or any Claude-specific signatures
4. **CONVENTIONAL FORMAT**: Always use type(scope): description format
5. **REFERENCE ISSUES**: Link commits to relevant issue numbers when applicable
6. **VERIFY BEFORE COMMIT**: Always run git diff --cached to review staged changes

## EXCLUSION RULES

### DO NOT:
1. **Bundle unrelated changes** - Separate features, fixes, and refactors into different commits
2. **Commit broken code** - Ensure code compiles/runs before committing
3. **Include debug artifacts** - Remove console.log, debug prints, temporary files
4. **Mix formatting with logic** - Separate style changes from functional changes
5. **Commit sensitive data** - Check for API keys, passwords, personal information

## Usage
```
/kuma:commit              # Analyze changes and create commits
/kuma:commit "message"    # Create commit with specific message
```

## METHODOLOGY

### Phase 1: Preparation

1. **Analyze current repository state**
   ```bash
   git status
   git diff HEAD
   git branch --show-current
   git log --oneline -5
   ```

2. **Determine change scope**
   - Identify modified files and their types
   - Group changes by purpose (features, fixes, docs, etc.)
   - Check for unstaged changes

3. **Review commit conventions**
   - Check recent commit history for project style
   - Identify conventional commit patterns used

### Phase 2: Execution

1. **Stage changes systematically**
   ```bash
   # Source code first
   git add src/ --exclude='*.test.*' --exclude='*.spec.*' --exclude='__tests__'
   
   # Configuration files
   git add package.json tsconfig.json *.config.js *.config.ts
   
   # Test files
   git add src/**/*.test.* src/**/*.spec.* src/__tests__/
   
   # Documentation
   git add docs/ *.md
   ```

2. **Create conventional commits**
   ```bash
   # Analyze staged changes
   git diff --cached --stat
   
   # Create commit with conventional format
   git commit -m "type(scope): description
   
   - Detail 1
   - Detail 2
   
   Closes #issue-number"
   ```

3. **Verify commit quality**
   ```bash
   # Check the created commit
   git show HEAD --stat
   
   # Ensure commit follows conventions
   git log -1 --pretty=format:"%s" | grep -E "^(feat|fix|docs|style|refactor|test|chore|perf|ci|build|revert)(\(.+\))?: .+"
   ```

### Phase 3: Output

1. **Display commit summary**
   - Show committed files and changes
   - Display commit message
   - List any remaining unstaged changes

2. **Provide next steps**
   - Suggest push command if on feature branch
   - Remind about PR creation if needed
   - Note any uncommitted changes

## OUTPUT FORMAT

### Minimum Requirements (MUST have)
- Commit hash and message
- Files changed with statistics (additions/deletions)
- Current branch name
- Any unstaged or untracked files remaining

### Recommended Structure (SHOULD follow)
```
‚úÖ Commit created successfully

Commit: [hash] type(scope): description
Branch: feature/branch-name

Changes:
  modified: src/file1.ts (+10, -5)
  added: src/file2.ts (+50)
  deleted: old-file.js (-100)

üìä Summary: 3 files changed, 60 insertions(+), 105 deletions(-)

‚ö†Ô∏è Remaining changes:
  - unstaged: config.json
  - untracked: temp.log

üìù Next steps:
  1. git push origin feature/branch-name
  2. Create PR if ready for review
```

## Project Configuration
See MCP steering document (type: steering, tag: conventions) for coding conventions

## Conventional Commit Types

- **feat**: New feature for users
- **fix**: Bug fix for users
- **docs**: Documentation changes only
- **style**: Code style changes (formatting, semicolons, etc.)
- **refactor**: Code changes that neither fix bugs nor add features
- **test**: Adding or correcting tests
- **chore**: Maintenance tasks (build, dependencies, etc.)
- **perf**: Performance improvements
- **ci**: CI/CD configuration changes
- **build**: Build system or external dependency changes
- **revert**: Reverting previous commits

## Best Practices

1. **Atomic commits**: Each commit should represent one logical change
2. **Clear messages**: Write commits as if explaining to a future developer
3. **Reference issues**: Link commits to relevant issue numbers
4. **No AI signatures**: Never include "Generated by AI" or similar references
5. **Consistent style**: Follow the project's established commit patterns